import numpy as np          # імпортування бібліотек
import random
import time


def bubble_sort():                                              # сортування бульбашками

    def bubble_sort_ascending():                                    # сортування бульбашками за зростанням
        start = time.time()                                     # змінна для початку відліку часу
        i, count, exchanges = 0, 1, 0                           # змінні для елементів масиву(і), рахунку кількості порівнянь(count), рахунку обмінів(exchanges)
        n = len(A)                                              # змінна для довжини масиву
        flag = True                                             # прапорець, який буде змінювати своє значення і таким чином переривати сортування, якщо масив вже відсортований
        while flag:                                             # цикл, який виконується, поки flag = True
            flag = False                                        # зміна прапорця, щоб перервати цикл
            count += 1                                          # виконується одне порівняння в циклі while (чи flag = True)
            for j in range(n - i - 1):                          # цикл для порівняння елементів масиву
                if A[j] > A[j + 1]:                             # порівняння елементу з наступним до нього
                    A[j], A[j + 1] = A[j + 1], A[j]             # якщо умова виконується, то елементи обмінюються позиціями і більший елемент зсувається вправо
                    flag = True                                 # зміна прапорця, бо масив ще не відсортований
                    count += 1                                  # додавання одного порівняння, яке відбувається в if
                    exchanges += 1                              # додавання одного обміну (якщо виконується умова елементи обмінюються позиціями 1 раз)
            i += 1                                              # додавання 1 до і - виключення одного елементу з сортування(це буде відбуватись далі в циклі for), бо він вже відсортований
        print(f'Bubble sorted ascending array: {A}')            # виведення відсортованого за зростанням масиву
        print(f'Quantity of comparisons: {count}')              # виведення кількості порівнянь, обмінів та секунд, витрачених на виконання функції
        print(f'Quantity of exchanges: {exchanges}')
        print(f'Time: {time.time() - start} seconds')
        print('--------------------------------------------------------------------')

    def bubble_sort_descending():
        start = time.time()                                     # змінна для початку відліку часу
        i, count, exchanges = 0, 1, 0                           # змінні для елементів масиву(і), рахунку кількості порівнянь(count), рахунку обмінів(exchanges)
        n = len(A)                                              # змінна для довжини масиву
        flag = True                                             # прапорець, який буде змінювати своє значення і таким чином переривати сортування, якщо масив вже відсортований
        while flag:                                             # цикл, який виконується, поки flag = True
            flag = False                                        # зміна прапорця, щоб перервати цикл
            count += 1                                          # виконується одне порівняння в циклі while (чи flag = True)
            for j in range(n - i - 1):                          # цикл для порівняння елементів масиву
                if A[j] > A[j + 1]:                             # порівняння елементу з наступним до нього
                    A[j], A[j + 1] = A[j + 1], A[j]             # якщо умова виконується, то елементи обмінюються позиціями і менший елемент зсувається вправо
                    flag = True                                 # зміна прапорця, бо масив ще не відсортований
                    count += 1                                  # додавання одного порівняння, яке відбувається в if
                    exchanges += 1                              # додавання одного обміну (якщо виконується умова елементи обмінюються позиціями 1 раз)
            i += 1                                              # додавання 1 до і - виключення одного елементу з сортування(це буде відбуватись далі в циклі for), бо він вже відсортований
        print(f'Bubble sorted descending array: {A}')           # виведення відсортованого за спаданням масиву
        print(f'Quantity of comparisons: {count}')              # виведення кількості порівнянь, обмінів та секунд, витрачених на виконання функції
        print(f'Quantity of exchanges: {exchanges}')
        print(f'Time: {time.time() - start} seconds')
        print('---------------------------------------------------------------------------------------------------------')

    answer2_1 = input('Choose type of sort: Ascending - 1; Descending - 2. Your answer is ')        # питання щодо сортування масиву за зростанням чи спаданням
    if answer2_1 == '1':
        bubble_sort_ascending()                                  # виклик функції бульбашкового сортування за зростанням
    elif answer2_1 == '2':
        bubble_sort_descending()                                 # виклик функції бульбашкового сортування за спаданням

def selection_sort():                                           # сортування за вибором

    def selection_sort_ascending():                             # сортування вибором за зростанням
        start = time.time()                                     # змінна для позначення часу
        n = len(A)                                              # змінна для позначення розмірності масиву А
        count, exchanges = 0, 0                                 # змінні для рахунку кількості порівнянь та обмінів
        for i in range(n - 1):                                  # цикл для порівняння елементів масиву
            min = i                                             # змінна для позначення позиції числа, яке ми вважаємо мінімальним
            for j in range(i + 1, n):                           # цикл для порівняння мінімального, на нашу думку, значення і наступного елемента після нього
                if A[min] > A[j]:                               # умова при якій наступний елемент більше мінімального
                    min = j                                     # якщо умова виконується, то мінімальним елементом вважається елемент на позиції j
                    exchanges += 1                              # додавання обмінів (виконується один)
                count += 1                                      # додавання порівнянь (одне в if)
            A[i], A[min] = A[min], A[i]                         # заміна мінімального, за припущенням, елементу на найменший
            exchanges += 1                                      # відбувся обмін, тому додаємо одиницю до лічильника
        print(f'Selection sorted ascending array: {A}')         # виведення відсортованого вибором масиву за зростанням
        print(f'Quantity of comparisons: {count}')              # виведення кількості порівнянь, обмінів та секунд, витрачених на виконання функції
        print(f'Quantity of exchanges: {exchanges}')
        print(f'Time: {time.time() - start} seconds')
        print('--------------------------------------------------------------------')

    def selection_sort_descending():                            # функція сортування вибором за зростанням
        start = time.time()                                     # змінна для позначення часу
        n = len(A)                                              # змінна для позначення розмірності масиву А
        count, exchanges = 0, 0                                 # змінні для рахунку кількості порівнянь та обмінів
        for i in range(n - 1):                                  # цикл для порівняння елементів масиву
            min = i                                             # змінна для позначення позиції числа, яке ми вважаємо мінімальним
            for j in range(i + 1, n):                           # цикл для порівняння мінімального, на нашу думку, значення і наступного елемента після нього
                if A[min] > A[j]:                               # умова при якій наступний елемент менший, мінімального
                    min = j                                     # якщо умова виконується, то мінімальним елементом вважається елемент на позиції j
                    exchanges += 1                              # додавання обмінів (виконується один)
                count += 1                                      # додавання порівнянь (одне в if)
            A[i], A[min] = A[min], A[i]                         # заміна мінімального, за припущенням, елементу на найменший
            exchanges += 1                                      # відбувся обмін, тому додаємо одиницю до лічильника
        print(f'Selection sorted descending array: {A}')        # виведення відсортованого вибором масиву за спаданням
        print(f'Quantity of comparisons: {count}')              # виведення кількості порівнянь, обмінів та секунд, витрачених на виконання функції
        print(f'Quantity of exchanges: {exchanges}')
        print(f'Time: {time.time() - start} seconds')
        print('---------------------------------------------------------------------------------------------------------')

    answer2_2 = input('Choose type of sort: Ascending - 1; Descending - 2. Your answer is ')        # питання щодо сортування масиву за зростанням чи спаданням
    if answer2_2 == '1':
        selection_sort_ascending()                                  # виклик функції сортування вибором за зростанням
    elif answer2_2 == '2':
        selection_sort_descending()                                 # виклик функції сортування вибором за спаданням

def insertion_sort():                                           # функція сортування вставками

    def insertion_sort_ascending():                             # функція сортування вставками за зростанням
        start = time.time()                                     # відлік часу
        count, exchanges = 1, 0                                 # змінні для позначення кількості порівнянь та обмінів
        for i in range(1, len(A)):                              # цикл для порівняння елементів масиву
            x = A[i]                                            # значення елемента масиву на і-тій позиції
            left = 0                                            # ліва границя
            right = i - 1                                       # права границя
            while left <= right:                                # цикл, що виконується, якщо ліва границя менша правої
                middle = (left + right) // 2                    # знаходження середини між границями
                if x < A[middle]:                               # якщо і-тий елемент менше середнього, то права границя зміщується
                    right = middle - 1
                else:                                           # в іншому випадку зміщується ліва границя
                    left = middle + 1
                count += 2                                      # додавання двох порівнянь (в циклі while та if)
            for j in range(i - 1, left - 1, -1):                # цикл для обміну елементів
                A[j + 1] = A[j]                                 # зміщення більших елементів масиву вправо
                exchanges += 1                                  # додавання обмінів
            A[left] = x                                         # заміна крайнього зліва елемента на найменший
            exchanges += 1                                      # додавання обмінів
        print(f'Insertion sorted ascending array: {A}')         # виведення відсортованого вставками масиву за зростанням
        print(f'Quantity of comparisons: {count}')              # виведення кількості порівнянь, обмінів та секунд, витрачених на виконання функції
        print(f'Quantity of exchanges: {exchanges}')
        print(f'Time: {time.time() - start} seconds')
        print('--------------------------------------------------------------------')

    def insertion_sort_descending():                            # функція сортування вставками за спаданням
        start = time.time()                                     # відлік часу
        count, exchanges = 1, 0                                 # змінні для позначення кількості порівнянь та обмінів
        for i in range(1, len(A)):                              # цикл для порівняння елементів масиву
            x = A[i]                                            # значення елемента масиву на і-тій позиції
            left = 0                                            # ліва границя
            right = i - 1                                       # права границя
            while left <= right:                                # цикл, що виконується, якщо ліва границя менша правої
                middle = (left + right) // 2                    # знаходження середини між границями
                if x > A[middle]:                               # якщо і-тий елемент більше середнього, то права границя зміщується
                    right = middle - 1
                else:                                           # в іншому випадку зміщується ліва границя
                    left = middle + 1
                count += 2                                      # додавання двох порівнянь (в циклі while та if)
            for j in range(i - 1, left - 1, -1):                # цикл для обміну елементів
                A[j + 1] = A[j]                                 # зміщення більших елементів масиву вліво
                exchanges += 1                                  # додавання обмінів
            A[left] = x                                         # заміна крайнього зліва елемента на найбільший
            exchanges += 1                                      # додавання обмінів
        print(f'Insertion sorted descending array: {A}')        # виведення вісортованого вставками масиву за спаданням
        print(f'Quantity of comparisons: {count}')              # виведення кількості порівнянь, обмінів та секунд, витрачених на виконання функції
        print(f'Quantity of exchanges: {exchanges}')
        print(f'Time: {time.time() - start} seconds')
        print('---------------------------------------------------------------------------------------------------------')

    answer2_3 = input('Choose type of sort: Ascending - 1; Descending - 2. Your answer is ')  # питання щодо сортування масиву за зростанням чи спаданням
    if answer2_3 == '1':
        insertion_sort_ascending()                                  # виклик функцій сортування вставками за зростанням
    elif answer2_3 == '2':
        insertion_sort_descending()                                 # виклик функції сортування вставками за спаданням


while True:                                                                                                 # зациклення всієї програми
    answer1 = input('Do you want to fill an array by yourself? Answer: YES or NO. Your answer is ')         # питання щодо заповнення масиву
    if answer1 == 'YES':                                                                                    # якщо відповідь так, користувач заповнює масив самостійно

        while True:                                                                                         # зациклення перевірки
            try:
                k = int(input('Quantity of elements in array = '))                                          # введення кількості елементів масиву
                break
            except ValueError:                                                                              # перехоплення помилок
                print('Only numbers')

        A = np.zeros(k-1, dtype=int)                                                                        # заповнення масиву нулями типу int
        for i in range(len(A)):                                                                             # цикл для проходження по елементам масиву
            A[i] = int(input(f'Element {i} = '))                                                            # заповнення масиву
        print(A)                                                                                            # виведення оновленого масиву

        answer2 = input('What sorting method do you want to use? Bubble sort - 1; Selection sort - 2; Insertion sort - 3. Your answer is ')     # питання щодо методу сортування
        if answer2 == '1':                                                                                  # якщо відповідь один, викликається функція бульбашкового сортування
            bubble_sort()
        elif answer2 == '2':                                                                                # якщо відповідь 2, викликається функція сортуваня за вибором
            selection_sort()
        elif answer2 == '3':                                                                                # якщо відповідь 3, викликається функція сортування вставками
            insertion_sort()


    elif answer1 == 'NO':                                                                                   # якщо відповідь ні, масиву заповнюється автоматично

        while True:                                                                                         # зациклення перевірки
            try:
                k = int(input('Quantity of elements in array = '))                                          # введення кількості елементів масиву
                break
            except ValueError:                                                                              # перехоплення помилок
                print('Only numbers')

        A = np.zeros(k-1, dtype=int)                                                                        # заповнення масиву нулями типу int
        for i in range(len(A)):                                                                             # цикл, для проходження по елементам масиву
            A[i] = random.randint(-10000, 10000)                                                            # введення рандомних значень в масив
        print(A)                                                                                            # виведення нового масиву

        answer2 = input('What sorting method do you want to use? Bubble sort - 1; Selection sort - 2; Insertion sort - 3. Your answer is ')     # питання щодо методу сортування
        if answer2 == '1':                                                                                  # якщо відповідь один, викликається функція бульбашкового сортування
            bubble_sort()
        elif answer2 == '2':                                                                                # якщо відповідь 2, викликається функція сортуваня за вибором
            selection_sort()
        elif answer2 == '3':                                                                                # якщо відповідь 3, викликається функція сортування вставками
            insertion_sort()


    answer = input('Restart? Yes - 1. No - other.')                                                         # питання щодо продовження роботи програми
    if answer == '1':
        continue
    else:
        break